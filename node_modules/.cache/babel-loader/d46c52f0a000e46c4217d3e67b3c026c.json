{"ast":null,"code":"/* ods.js (C) 2014 SheetJS -- http://sheetjs.com */\n\n/* vim: set ts=2: */\n\n/*jshint -W041 */\nvar ODS = {};\n\n(function make_ods(ODS) {\n  /* Open Document Format for Office Applications (OpenDocument) Version 1.2 */\n  var get_utils = function get_utils() {\n    if (typeof XLSX !== 'undefined') return XLSX.utils;\n    if (typeof module !== \"undefined\" && typeof require !== 'undefined') try {\n      return require('../' + 'xlsx').utils;\n    } catch (e) {\n      try {\n        return require('./' + 'xlsx').utils;\n      } catch (ee) {\n        return require('xl' + 'sx').utils;\n      }\n    }\n    throw new Error(\"Cannot find XLSX utils\");\n  };\n\n  var has_buf = typeof Buffer !== 'undefined';\n\n  function cc2str(arr) {\n    var o = \"\";\n\n    for (var i = 0; i != arr.length; ++i) {\n      o += String.fromCharCode(arr[i]);\n    }\n\n    return o;\n  }\n\n  function getdata(data) {\n    if (!data) return null;\n    if (data.data) return data.data;\n    if (data.asNodeBuffer && has_buf) return data.asNodeBuffer().toString('binary');\n    if (data.asBinary) return data.asBinary();\n    if (data._data && data._data.getContent) return cc2str(Array.prototype.slice.call(data._data.getContent(), 0));\n    return null;\n  }\n\n  function safegetzipfile(zip, file) {\n    var f = file;\n    if (zip.files[f]) return zip.files[f];\n    f = file.toLowerCase();\n    if (zip.files[f]) return zip.files[f];\n    f = f.replace(/\\//g, '\\\\');\n    if (zip.files[f]) return zip.files[f];\n    return null;\n  }\n\n  function getzipfile(zip, file) {\n    var o = safegetzipfile(zip, file);\n    if (o == null) throw new Error(\"Cannot find file \" + file + \" in zip\");\n    return o;\n  }\n\n  function getzipdata(zip, file, safe) {\n    if (!safe) return getdata(getzipfile(zip, file));\n    if (!file) return null;\n\n    try {\n      return getzipdata(zip, file);\n    } catch (e) {\n      return null;\n    }\n  }\n\n  var _fs, jszip;\n\n  if (typeof JSZip !== 'undefined') jszip = JSZip;\n\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      if (has_buf && typeof jszip === 'undefined') jszip = require('js' + 'zip');\n      if (typeof jszip === 'undefined') jszip = require('./js' + 'zip').JSZip;\n      _fs = require('f' + 's');\n    }\n  }\n\n  var attregexg = /\\b[\\w:-]+=[\"'][^\"]*['\"]/g;\n  var tagregex = /<[^>]*>/g;\n  var nsregex = /<\\w*:/,\n      nsregex2 = /<(\\/?)\\w+:/;\n\n  function parsexmltag(tag, skip_root) {\n    var z = [];\n    var eq = 0,\n        c = 0;\n\n    for (; eq !== tag.length; ++eq) {\n      if ((c = tag.charCodeAt(eq)) === 32 || c === 10 || c === 13) break;\n    }\n\n    if (!skip_root) z[0] = tag.substr(0, eq);\n    if (eq === tag.length) return z;\n    var m = tag.match(attregexg),\n        j = 0,\n        w = \"\",\n        v = \"\",\n        i = 0,\n        q = \"\",\n        cc = \"\";\n    if (m) for (i = 0; i != m.length; ++i) {\n      cc = m[i];\n\n      for (c = 0; c != cc.length; ++c) {\n        if (cc.charCodeAt(c) === 61) break;\n      }\n\n      q = cc.substr(0, c);\n      v = cc.substring(c + 2, cc.length - 1);\n\n      for (j = 0; j != q.length; ++j) {\n        if (q.charCodeAt(j) === 58) break;\n      }\n\n      if (j === q.length) z[q] = v;else z[(j === 5 && q.substr(0, 5) === \"xmlns\" ? \"xmlns\" : \"\") + q.substr(j + 1)] = v;\n    }\n    return z;\n  }\n\n  function strip_ns(x) {\n    return x.replace(nsregex2, \"<$1\");\n  }\n\n  var encodings = {\n    '&quot;': '\"',\n    '&apos;': \"'\",\n    '&gt;': '>',\n    '&lt;': '<',\n    '&amp;': '&'\n  };\n  var rencoding = {\n    '\"': '&quot;',\n    \"'\": '&apos;',\n    '>': '&gt;',\n    '<': '&lt;',\n    '&': '&amp;'\n  };\n  var rencstr = \"&<>'\\\"\".split(\"\"); // TODO: CP remap (need to read file version to determine OS)\n\n  var encregex = /&[a-z]*;/g,\n      coderegex = /_x([\\da-fA-F]+)_/g;\n\n  function unescapexml(text) {\n    var s = text + '';\n    return s.replace(encregex, function ($$) {\n      return encodings[$$];\n    }).replace(coderegex, function (m, c) {\n      return String.fromCharCode(parseInt(c, 16));\n    });\n  }\n\n  var decregex = /[&<>'\"]/g,\n      charegex = /[\\u0000-\\u0008\\u000b-\\u001f]/g;\n\n  function escapexml(text) {\n    var s = text + '';\n    return s.replace(decregex, function (y) {\n      return rencoding[y];\n    }).replace(charegex, function (s) {\n      return \"_x\" + (\"000\" + s.charCodeAt(0).toString(16)).substr(-4) + \"_\";\n    });\n  }\n\n  function parsexmlbool(value, tag) {\n    switch (value) {\n      case '1':\n      case 'true':\n      case 'TRUE':\n        return true;\n\n      /* case '0': case 'false': case 'FALSE':*/\n\n      default:\n        return false;\n    }\n  }\n\n  function datenum(v) {\n    var epoch = Date.parse(v);\n    return (epoch + 2209161600000) / (24 * 60 * 60 * 1000);\n  }\n  /* ISO 8601 Duration */\n\n\n  function parse_isodur(s) {\n    var sec = 0,\n        mt = 0,\n        time = false;\n    var m = s.match(/P([0-9\\.]+Y)?([0-9\\.]+M)?([0-9\\.]+D)?T([0-9\\.]+H)?([0-9\\.]+M)?([0-9\\.]+S)?/);\n    if (!m) throw new Error(\"|\" + s + \"| is not an ISO8601 Duration\");\n\n    for (var i = 1; i != m.length; ++i) {\n      if (!m[i]) continue;\n      mt = 1;\n      if (i > 3) time = true;\n\n      switch (m[i].substr(m[i].length - 1)) {\n        case 'Y':\n          throw new Error(\"Unsupported ISO Duration Field: \" + m[i].substr(m[i].length - 1));\n\n        case 'D':\n          mt *= 24;\n\n        /* falls through */\n\n        case 'H':\n          mt *= 60;\n\n        /* falls through */\n\n        case 'M':\n          if (!time) throw new Error(\"Unsupported ISO Duration Field: M\");else mt *= 60;\n\n        /* falls through */\n\n        case 'S':\n          break;\n      }\n\n      sec += mt * parseInt(m[i], 10);\n    }\n\n    return sec;\n  }\n  /* copied from js-xls (C) SheetJS Apache2 license */\n\n\n  function xlml_normalize(d) {\n    if (has_buf && Buffer.isBuffer(d)) return d.toString('utf8');\n    if (typeof d === 'string') return d;\n    throw \"badf\";\n  }\n\n  var xlmlregex = /<(\\/?)([a-z0-9]*:|)([\\w-]+)[^>]*>/mg;\n  /* Part 3 Section 4 Manifest File */\n\n  var CT_ODS = \"application/vnd.oasis.opendocument.spreadsheet\";\n\n  var parse_manifest = function parse_manifest(d, opts) {\n    var str = xlml_normalize(d);\n    var Rn;\n    var FEtag;\n\n    while (Rn = xlmlregex.exec(str)) {\n      switch (Rn[3]) {\n        case 'manifest':\n          break;\n        // 4.2 <manifest:manifest>\n\n        case 'file-entry':\n          // 4.3 <manifest:file-entry>\n          FEtag = parsexmltag(Rn[0]);\n          if (FEtag.path == '/' && FEtag.type !== CT_ODS) throw new Error(\"This OpenDocument is not a spreadsheet\");\n          break;\n\n        case 'encryption-data': // 4.4 <manifest:encryption-data>\n\n        case 'algorithm': // 4.5 <manifest:algorithm>\n\n        case 'start-key-generation': // 4.6 <manifest:start-key-generation>\n\n        case 'key-derivation':\n          // 4.7 <manifest:key-derivation>\n          throw new Error(\"Unsupported ODS Encryption\");\n\n        default:\n          throw Rn;\n      }\n    }\n  };\n\n  var parse_text_p = function parse_text_p(text, tag) {\n    return utf8read(text.replace(/<text:s\\/>/g, \" \").replace(/<[^>]*>/g, \"\"));\n  };\n\n  var utf8read = function utf8reada(orig) {\n    var out = \"\",\n        i = 0,\n        c = 0,\n        d = 0,\n        e = 0,\n        f = 0,\n        w = 0;\n\n    while (i < orig.length) {\n      c = orig.charCodeAt(i++);\n\n      if (c < 128) {\n        out += String.fromCharCode(c);\n        continue;\n      }\n\n      d = orig.charCodeAt(i++);\n\n      if (c > 191 && c < 224) {\n        out += String.fromCharCode((c & 31) << 6 | d & 63);\n        continue;\n      }\n\n      e = orig.charCodeAt(i++);\n\n      if (c < 240) {\n        out += String.fromCharCode((c & 15) << 12 | (d & 63) << 6 | e & 63);\n        continue;\n      }\n\n      f = orig.charCodeAt(i++);\n      w = ((c & 7) << 18 | (d & 63) << 12 | (e & 63) << 6 | f & 63) - 65536;\n      out += String.fromCharCode(0xD800 + (w >>> 10 & 1023));\n      out += String.fromCharCode(0xDC00 + (w & 1023));\n    }\n\n    return out;\n  };\n\n  var parse_content_xml = function () {\n    var number_formats = {\n      /* ods name: [short ssf fmt, long ssf fmt] */\n      day: [\"d\", \"dd\"],\n      month: [\"m\", \"mm\"],\n      year: [\"y\", \"yy\"],\n      hours: [\"h\", \"hh\"],\n      minutes: [\"m\", \"mm\"],\n      seconds: [\"s\", \"ss\"],\n      \"am-pm\": [\"A/P\", \"AM/PM\"],\n      \"day-of-week\": [\"ddd\", \"dddd\"]\n    };\n    return function pcx(d, opts) {\n      var str = xlml_normalize(d);\n      var state = [],\n          tmp;\n      var tag;\n      var NFtag, NF, pidx;\n      var sheetag;\n      var Sheets = {},\n          SheetNames = [],\n          ws = {};\n      var Rn, q;\n      var ctag;\n      var textp, textpidx, textptag;\n      var R,\n          C,\n          range = {\n        s: {\n          r: 1000000,\n          c: 10000000\n        },\n        e: {\n          r: 0,\n          c: 0\n        }\n      };\n      var number_format_map = {};\n      var merges = [],\n          mrange = {},\n          mR = 0,\n          mC = 0;\n\n      while (Rn = xlmlregex.exec(str)) {\n        switch (Rn[3]) {\n          case 'table':\n            // 9.1.2 <table:table>\n            if (Rn[1] === '/') {\n              if (range.e.c >= range.s.c && range.e.r >= range.s.r) ws['!ref'] = get_utils().encode_range(range);\n              if (merges.length) ws['!merges'] = merges;\n              SheetNames.push(sheetag.name);\n              Sheets[sheetag.name] = ws;\n            } else if (Rn[0].charAt(Rn[0].length - 2) !== '/') {\n              sheetag = parsexmltag(Rn[0]);\n              R = C = -1;\n              range.s.r = range.s.c = 10000000;\n              range.e.r = range.e.c = 0;\n              ws = {};\n              merges = [];\n            }\n\n            break;\n\n          case 'table-row':\n            // 9.1.3 <table:table-row>\n            if (Rn[1] === '/') break;\n            ++R;\n            C = -1;\n            break;\n\n          case 'covered-table-cell':\n            // 9.1.5 table:covered-table-cell\n            ++C;\n            break;\n\n          /* stub */\n\n          case 'table-cell':\n            if (Rn[0].charAt(Rn[0].length - 2) === '/') {\n              ctag = parsexmltag(Rn[0]);\n              if (ctag['number-columns-repeated']) C += parseInt(ctag['number-columns-repeated'], 10);else ++C;\n            } else if (Rn[1] !== '/') {\n              ++C;\n              if (C > range.e.c) range.e.c = C;\n              if (R > range.e.r) range.e.r = R;\n              if (C < range.s.c) range.s.c = C;\n              if (R < range.s.r) range.s.r = R;\n              ctag = parsexmltag(Rn[0]);\n              q = {\n                t: ctag['value-type'],\n                v: null\n              };\n\n              if (ctag['number-columns-spanned'] || ctag['number-rows-spanned']) {\n                mR = parseInt(ctag['number-rows-spanned'], 10) || 0;\n                mC = parseInt(ctag['number-columns-spanned'], 10) || 0;\n                mrange = {\n                  s: {\n                    r: R,\n                    c: C\n                  },\n                  e: {\n                    r: R + mR - 1,\n                    c: C + mC - 1\n                  }\n                };\n                merges.push(mrange);\n              }\n              /* 19.385 office:value-type */\n\n\n              switch (q.t) {\n                case 'boolean':\n                  q.t = 'b';\n                  q.v = parsexmlbool(ctag['boolean-value']);\n                  break;\n\n                case 'float':\n                  q.t = 'n';\n                  q.v = parseFloat(ctag.value);\n                  break;\n\n                case 'percentage':\n                  q.t = 'n';\n                  q.v = parseFloat(ctag.value);\n                  break;\n\n                case 'currency':\n                  q.t = 'n';\n                  q.v = parseFloat(ctag.value);\n                  break;\n\n                case 'date':\n                  q.t = 'n';\n                  q.v = datenum(ctag['date-value']);\n                  q.z = 'm/d/yy';\n                  break;\n\n                case 'time':\n                  q.t = 'n';\n                  q.v = parse_isodur(ctag['time-value']) / 86400;\n                  break;\n\n                case 'string':\n                  q.t = 's';\n                  break;\n\n                default:\n                  throw new Error('Unsupported value type ' + q.t);\n              }\n            } else {\n              if (q.t === 's') q.v = textp;\n              if (textp) q.w = textp;\n              if (!(opts.sheetRows && opts.sheetRows < R)) ws[get_utils().encode_cell({\n                r: R,\n                c: C\n              })] = q;\n              q = null;\n            }\n\n            break;\n          // 9.1.4 <table:table-cell>\n\n          /* pure state */\n\n          case 'document-content': // 3.1.3.2 <office:document-content>\n\n          case 'spreadsheet': // 3.7 <office:spreadsheet>\n\n          case 'scripts': // 3.12 <office:scripts>\n\n          case 'font-face-decls':\n            // 3.14 <office:font-face-decls>\n            if (Rn[1] === '/') {\n              if ((tmp = state.pop())[0] !== Rn[3]) throw \"Bad state: \" + tmp;\n            } else if (Rn[0].charAt(Rn[0].length - 2) !== '/') state.push([Rn[3], true]);\n\n            break;\n\n          /* ignore state */\n\n          case 'shapes': // 9.2.8 <table:shapes>\n\n          case 'frame':\n            // 10.4.2 <draw:frame>\n            if (Rn[1] === '/') {\n              if ((tmp = state.pop())[0] !== Rn[3]) throw \"Bad state: \" + tmp;\n            } else if (Rn[0].charAt(Rn[0].length - 2) !== '/') state.push([Rn[3], false]);\n\n            break;\n\n          case 'number-style': // 16.27.2 <number:number-style>\n\n          case 'percentage-style': // 16.27.9 <number:percentage-style>\n\n          case 'date-style': // 16.27.10 <number:date-style>\n\n          case 'time-style':\n            // 16.27.18 <number:time-style>\n            if (Rn[1] === '/') {\n              number_format_map[NFtag.name] = NF;\n              if ((tmp = state.pop())[0] !== Rn[3]) throw \"Bad state: \" + tmp;\n            } else if (Rn[0].charAt(Rn[0].length - 2) !== '/') {\n              NF = \"\";\n              NFtag = parsexmltag(Rn[0]);\n              state.push([Rn[3], true]);\n            }\n\n            break;\n\n          case 'script':\n            break;\n          // 3.13 <office:script>\n\n          case 'automatic-styles':\n            break;\n          // 3.15.3 <office:automatic-styles>\n\n          case 'style':\n            break;\n          // 16.2 <style:style>\n\n          case 'font-face':\n            break;\n          // 16.21 <style:font-face>\n\n          case 'paragraph-properties':\n            break;\n          // 17.6 <style:paragraph-properties>\n\n          case 'table-properties':\n            break;\n          // 17.15 <style:table-properties>\n\n          case 'table-column-properties':\n            break;\n          // 17.16 <style:table-column-properties>\n\n          case 'table-row-properties':\n            break;\n          // 17.17 <style:table-row-properties>\n\n          case 'table-cell-properties':\n            break;\n          // 17.18 <style:table-cell-properties>\n\n          case 'number':\n            // 16.27.3 <number:number>\n            switch (state[state.length - 1][0]) {\n              case 'time-style':\n              case 'date-style':\n                tag = parsexmltag(Rn[0]);\n                NF += number_formats[Rn[3]][tag.style === 'long' ? 1 : 0];\n                break;\n            }\n\n            break;\n\n          case 'day': // 16.27.11 <number:day>\n\n          case 'month': // 16.27.12 <number:month>\n\n          case 'year': // 16.27.13 <number:year>\n\n          case 'era': // 16.27.14 <number:era>\n\n          case 'day-of-week': // 16.27.15 <number:day-of-week>\n\n          case 'week-of-year': // 16.27.16 <number:week-of-year>\n\n          case 'quarter': // 16.27.17 <number:quarter>\n\n          case 'hours': // 16.27.19 <number:hours>\n\n          case 'minutes': // 16.27.20 <number:minutes>\n\n          case 'seconds': // 16.27.21 <number:seconds>\n\n          case 'am-pm':\n            // 16.27.22 <number:am-pm>\n            switch (state[state.length - 1][0]) {\n              case 'time-style':\n              case 'date-style':\n                tag = parsexmltag(Rn[0]);\n                NF += number_formats[Rn[3]][tag.style === 'long' ? 1 : 0];\n                break;\n            }\n\n            break;\n\n          case 'boolean-style':\n            break;\n          // 16.27.23 <number:boolean-style>\n\n          case 'boolean':\n            break;\n          // 16.27.24 <number:boolean>\n\n          case 'text-style':\n            break;\n          // 16.27.25 <number:text-style>\n\n          case 'text':\n            // 16.27.26 <number:text>\n            if (Rn[0].substr(-2) === \"/>\") break;else if (Rn[1] === \"/\") switch (state[state.length - 1][0]) {\n              case 'number-style':\n              case 'date-style':\n              case 'time-style':\n                NF += str.slice(pidx, Rn.index);\n                break;\n            } else pidx = Rn.index + Rn[0].length;\n            break;\n\n          case 'text-content':\n            break;\n          // 16.27.27 <number:text-content>\n\n          case 'text-properties':\n            break;\n          // 16.27.27 <style:text-properties>\n\n          case 'body':\n            break;\n          // 3.3 16.9.6 19.726.3\n\n          case 'forms':\n            break;\n          // 12.25.2 13.2\n\n          case 'table-column':\n            break;\n          // 9.1.6 <table:table-column>\n\n          case 'graphic-properties':\n            break;\n\n          case 'calculation-settings':\n            break;\n          // 9.4.1 <table:calculation-settings>\n\n          case 'named-expressions':\n            break;\n          // 9.4.11 <table:named-expressions>\n\n          case 'named-range':\n            break;\n          // 9.4.11 <table:named-range>\n\n          case 'span':\n            break;\n          // <text:span>\n\n          case 'p':\n            if (Rn[1] === '/') textp = parse_text_p(str.slice(textpidx, Rn.index), textptag);else {\n              textptag = parsexmltag(Rn[0]);\n              textpidx = Rn.index + Rn[0].length;\n            }\n            break;\n          // <text:p>\n\n          case 's':\n            break;\n          // <text:s>\n\n          case 'date':\n            break;\n          // <*:date>\n\n          case 'annotation':\n            break;\n\n          case 'object':\n            break;\n          // 10.4.6.2 <draw:object>\n\n          case 'title':\n            break;\n          // <*:title>\n\n          case 'desc':\n            break;\n          // <*:desc>\n\n          case 'database-ranges':\n            break;\n          // 9.4.14 <table:database-ranges>\n\n          case 'database-range':\n            break;\n          // 9.4.15 <table:database-range>\n\n          case 'filter':\n            break;\n          // 9.5.2 <table:filter>\n\n          case 'filter-and':\n            break;\n          // 9.5.3 <table:filter-and>\n\n          case 'filter-or':\n            break;\n          // 9.5.4 <table:filter-or>\n\n          case 'filter-condition':\n            break;\n          // 9.5.5 <table:filter-condition>\n\n          default:\n            if (opts.WTF) throw Rn;\n        }\n      }\n\n      var out = {\n        Sheets: Sheets,\n        SheetNames: SheetNames\n      };\n      return out;\n    };\n  }();\n  /* Part 3: Packages */\n\n\n  var parse_ods = function parse_ods(zip, opts) {\n    //var manifest = parse_manifest(getzipdata(zip, 'META-INF/manifest.xml'));\n    return parse_content_xml(getzipdata(zip, 'content.xml'), opts);\n  };\n\n  ODS.parse_ods = parse_ods;\n})(typeof exports !== 'undefined' ? exports : ODS);","map":null,"metadata":{},"sourceType":"script"}